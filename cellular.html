<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Cellular Automaton</title>
    <style type="text/css">


* {
  box-sizing: border-box;
}

div#controls {
  position: fixed;
  background-color: rgba(255, 255, 255, 0.8);
  border-radius: 3px;
}

div.control {
  display: inline-block;
  width: 30px;
  text-align: center;
  margin: 3px;
}

div.border {
  display: inline-block;
  float: left;
}

div.border, td.border {
  width: 10px;
  height: 10px;
  border: 1px solid black;
}

div.border.black, td.border.black {
  background-color: black;
}

div.border.white, td.border.white {
  background-color: white;
}


    </style>
    <script type="application/javascript">


var getBitArray = function (n, count) {
  var binaryString = n.toString(2);
  count = count || binaryString.length;

  var result = [];
  var missingCount = count - binaryString.length;
  for (var i = 0; i < count; i++) {
    if(i < missingCount) {
      result[i] = false;
    } else {
      result[i] = binaryString[i - missingCount] === '1';
    }
  }
  return result;
}

function Controls(container) {
  this.inputElements = [];
  this.randomize = false;

  for (var i = 0; i < 8; i++) {
    var controlElement = document.createElement('div');
    controlElement.className = 'control';

    var neighborhoodWidth = 3;
    var bits = getBitArray(i, neighborhoodWidth);

    for (var j = 0; j < neighborhoodWidth; j++) {
      var blockElement = document.createElement('div');
      blockElement.className = 'border ' + (bits[j] ? 'white' : 'black');
      controlElement.appendChild(blockElement);
    }

    var checkboxElement = document.createElement('input');
    checkboxElement.type = 'checkbox';
    checkboxElement.addEventListener('click', draw);
    controlElement.appendChild(checkboxElement);
    this.inputElements.push(checkboxElement);

    container.appendChild(controlElement);
  }

  var labelElement = document.createElement('label');

  var randomizeElement = document.createElement('input');
  randomizeElement.type = 'checkbox';
  if(this.randomize) {
    randomizeElement.checked = 'checked';
  }
  var controls = this;
  randomizeElement.addEventListener('click', function (e) {
    controls.randomize = e.target.checked;
    draw();
  });

  labelElement.textContent = 'Random Input';
  labelElement.insertBefore(randomizeElement, labelElement.firstChild);

  container.appendChild(labelElement);

  return this;
} 

Controls.prototype.getBitArray = function () {
    var result = [];
    for (var i = 0; i < this.inputElements.length; i++) {
      result[i] = this.inputElements[i].checked;
    }
    return result;
};

Controls.prototype.set = function (n) {
  var isChecked = getBitArray(n, this.inputElements.length);

  for(var i = 0; i < this.inputElements.length; ++i) {
    this.inputElements[i].checked = isChecked[i] ? 'checked' : '';
  }
}

var controls;

function init() {
  var container = document.getElementById('controls');
  controls = new Controls(container);

  // center canvas
  // NOTE(vlaube): won't work without timeout, don't know why
  window.setTimeout(function() {
    window.scrollTo((document.body.scrollWidth - window.screen.availWidth) / 2, 0)
  }, 1);

  // rule 30 https://en.wikipedia.org/wiki/Rule_30
  var rule = 30;

  // rule 90 https://en.wikipedia.org/wiki/Rule_90
  // var rule = 90;

  // rule 110 https://en.wikipedia.org/wiki/Rule_110
  // var rule = 110;

  controls.set(rule);
}

var timerIds = [];
function draw() {
  var minH = 0;
  var maxH = 100;
  var diff = maxH - minH;
  var canvas = document.getElementById('canvas');
  var sleepTime = 1;

  while (timerIds.length > 0) {
    var timerId = timerIds.pop();
    window.clearTimeout(timerId);
  }

  timerIds.push(window.setTimeout(function drawIteration() {
    drawSegment(minH, maxH);

    if(minH < canvas.height) {
      minH += diff;
      maxH += diff;

      if(maxH > canvas.height) {
        maxH = canvas.height;
      }

      timerIds.push(window.setTimeout(drawIteration, sleepTime));
    }

  }, sleepTime));
}

function drawSegment(minH, maxH) {
  var canvas = document.getElementById('canvas');

  var ctx = canvas.getContext('2d');
  var w = canvas.width;
  
  var r = controls.getBitArray();

  var white = 0xFFFFFFFF;
  var black = 0xff000000;
  var colors = [
    0xFFFF00FF, // fuchsia
    0xFF0000FF, // red
    0xFF00A5FF, // orange
    0xFF00FFFF, // yellow
    0xFF008000, // green
    0xFFFF901E, // dodgerblue
    0xFF800000, // navy
    0xFF800080, // purple
  ];

  if(minH>0) minH--;

  var imageY = minH;
  var imageH = maxH-minH;
  var imageData = ctx.getImageData(0, imageY, w, imageH);
  var pixels = new Uint32Array(imageData.data.buffer);

  // initialize first row
  if(minH == 0) {
    for(var x = 0; x < w; x++) {
      var color;

      if(controls.randomize) {
        color = Math.random() > 0.5 ? black : white;
      } else {
        var isCenter = x == (Math.floor(w / 2));
        color = isCenter ? black : white;
      }

      pixels[x] = color;
    }
  }

  var outIndex = w;
  var inIndex = 0;

  for(var y = minH; y < maxH; y++) {
    for(var x = 0; x < w; x++) {
      var prevPixel = (x > 0) ? pixels[inIndex + x - 1] : white;
      var currPixel = pixels[inIndex + x];
      var nextPixel = (x < w - 1) ? pixels[inIndex + x + 1] : white;
      
      var prevBit = (prevPixel === white || prevPixel === undefined) ? 1 : 0;
      var currBit = (currPixel === white) ? 1 : 0;
      var nextBit = (nextPixel === white || nextPixel === undefined) ? 1 : 0;

      var colorIndex = prevBit << 2 | currBit << 1 | nextBit << 0;
      var color = r[colorIndex] ? colors[colorIndex] : white;

      pixels[outIndex + x] = color;
    }
    outIndex += w;
    inIndex += w;
  }

  ctx.putImageData(imageData, 0, minH);
}


    </script>
  </head>
  <body onload="init();draw();">
    <div id="controls"></div>
    <canvas id="canvas" width="5000" height="2500"></canvas>
    </body>
 </html>
